import type { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PayableOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import type { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type { TypedEventFilter, TypedEvent, TypedListener, OnEvent, PromiseOrValue } from "./common";
export interface TokenSaleInterface extends utils.Interface {
    functions: {
        "claim(address)": FunctionFragment;
        "claimAmount(address)": FunctionFragment;
        "deposit(address)": FunctionFragment;
        "depositForWhitelistedAddress(uint256,address,bytes32[])": FunctionFragment;
        "deposits(address)": FunctionFragment;
        "dpx()": FunctionFragment;
        "dpxTokensAllocated()": FunctionFragment;
        "isWhitelistedAddressDeposited(uint256)": FunctionFragment;
        "maxDeposits()": FunctionFragment;
        "maxWhitelistDeposit()": FunctionFragment;
        "merkleRoot()": FunctionFragment;
        "owner()": FunctionFragment;
        "rdpx()": FunctionFragment;
        "rdpxTokensAllocated()": FunctionFragment;
        "saleClose()": FunctionFragment;
        "saleStart()": FunctionFragment;
        "saleWhitelistStart()": FunctionFragment;
        "totalSaleParticipants()": FunctionFragment;
        "weiDeposited()": FunctionFragment;
        "withdraw()": FunctionFragment;
    };
    getFunction(nameOrSignatureOrTopic: "claim" | "claimAmount" | "deposit" | "depositForWhitelistedAddress" | "deposits" | "dpx" | "dpxTokensAllocated" | "isWhitelistedAddressDeposited" | "maxDeposits" | "maxWhitelistDeposit" | "merkleRoot" | "owner" | "rdpx" | "rdpxTokensAllocated" | "saleClose" | "saleStart" | "saleWhitelistStart" | "totalSaleParticipants" | "weiDeposited" | "withdraw"): FunctionFragment;
    encodeFunctionData(functionFragment: "claim", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "claimAmount", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "deposit", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "depositForWhitelistedAddress", values: [
        PromiseOrValue<BigNumberish>,
        PromiseOrValue<string>,
        PromiseOrValue<BytesLike>[]
    ]): string;
    encodeFunctionData(functionFragment: "deposits", values: [PromiseOrValue<string>]): string;
    encodeFunctionData(functionFragment: "dpx", values?: undefined): string;
    encodeFunctionData(functionFragment: "dpxTokensAllocated", values?: undefined): string;
    encodeFunctionData(functionFragment: "isWhitelistedAddressDeposited", values: [PromiseOrValue<BigNumberish>]): string;
    encodeFunctionData(functionFragment: "maxDeposits", values?: undefined): string;
    encodeFunctionData(functionFragment: "maxWhitelistDeposit", values?: undefined): string;
    encodeFunctionData(functionFragment: "merkleRoot", values?: undefined): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "rdpx", values?: undefined): string;
    encodeFunctionData(functionFragment: "rdpxTokensAllocated", values?: undefined): string;
    encodeFunctionData(functionFragment: "saleClose", values?: undefined): string;
    encodeFunctionData(functionFragment: "saleStart", values?: undefined): string;
    encodeFunctionData(functionFragment: "saleWhitelistStart", values?: undefined): string;
    encodeFunctionData(functionFragment: "totalSaleParticipants", values?: undefined): string;
    encodeFunctionData(functionFragment: "weiDeposited", values?: undefined): string;
    encodeFunctionData(functionFragment: "withdraw", values?: undefined): string;
    decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "claimAmount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "depositForWhitelistedAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deposits", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dpx", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "dpxTokensAllocated", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isWhitelistedAddressDeposited", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxDeposits", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxWhitelistDeposit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "merkleRoot", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rdpx", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rdpxTokensAllocated", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "saleClose", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "saleStart", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "saleWhitelistStart", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalSaleParticipants", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "weiDeposited", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
    events: {
        "TokenClaim(address,address,uint256)": EventFragment;
        "TokenDeposit(address,address,bool,uint256)": EventFragment;
        "WithdrawEth(uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "TokenClaim"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokenDeposit"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "WithdrawEth"): EventFragment;
}
export interface TokenClaimEventObject {
    claimer: string;
    beneficiary: string;
    amount: BigNumber;
}
export declare type TokenClaimEvent = TypedEvent<[
    string,
    string,
    BigNumber
], TokenClaimEventObject>;
export declare type TokenClaimEventFilter = TypedEventFilter<TokenClaimEvent>;
export interface TokenDepositEventObject {
    purchaser: string;
    beneficiary: string;
    isWhitelistDeposit: boolean;
    value: BigNumber;
}
export declare type TokenDepositEvent = TypedEvent<[
    string,
    string,
    boolean,
    BigNumber
], TokenDepositEventObject>;
export declare type TokenDepositEventFilter = TypedEventFilter<TokenDepositEvent>;
export interface WithdrawEthEventObject {
    amount: BigNumber;
}
export declare type WithdrawEthEvent = TypedEvent<[BigNumber], WithdrawEthEventObject>;
export declare type WithdrawEthEventFilter = TypedEventFilter<WithdrawEthEvent>;
export interface TokenSale extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: TokenSaleInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        claim(beneficiary: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        claimAmount(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        deposit(beneficiary: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        depositForWhitelistedAddress(index: PromiseOrValue<BigNumberish>, beneficiary: PromiseOrValue<string>, merkleProof: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
        deposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<[BigNumber]>;
        dpx(overrides?: CallOverrides): Promise<[string]>;
        dpxTokensAllocated(overrides?: CallOverrides): Promise<[BigNumber]>;
        isWhitelistedAddressDeposited(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<[boolean]>;
        maxDeposits(overrides?: CallOverrides): Promise<[BigNumber]>;
        maxWhitelistDeposit(overrides?: CallOverrides): Promise<[BigNumber]>;
        merkleRoot(overrides?: CallOverrides): Promise<[string]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        rdpx(overrides?: CallOverrides): Promise<[string]>;
        rdpxTokensAllocated(overrides?: CallOverrides): Promise<[BigNumber]>;
        saleClose(overrides?: CallOverrides): Promise<[BigNumber]>;
        saleStart(overrides?: CallOverrides): Promise<[BigNumber]>;
        saleWhitelistStart(overrides?: CallOverrides): Promise<[BigNumber]>;
        totalSaleParticipants(overrides?: CallOverrides): Promise<[BigNumber]>;
        weiDeposited(overrides?: CallOverrides): Promise<[BigNumber]>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<ContractTransaction>;
    };
    claim(beneficiary: PromiseOrValue<string>, overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    claimAmount(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    deposit(beneficiary: PromiseOrValue<string>, overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    depositForWhitelistedAddress(index: PromiseOrValue<BigNumberish>, beneficiary: PromiseOrValue<string>, merkleProof: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    deposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
    dpx(overrides?: CallOverrides): Promise<string>;
    dpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
    isWhitelistedAddressDeposited(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
    maxDeposits(overrides?: CallOverrides): Promise<BigNumber>;
    maxWhitelistDeposit(overrides?: CallOverrides): Promise<BigNumber>;
    merkleRoot(overrides?: CallOverrides): Promise<string>;
    owner(overrides?: CallOverrides): Promise<string>;
    rdpx(overrides?: CallOverrides): Promise<string>;
    rdpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
    saleClose(overrides?: CallOverrides): Promise<BigNumber>;
    saleStart(overrides?: CallOverrides): Promise<BigNumber>;
    saleWhitelistStart(overrides?: CallOverrides): Promise<BigNumber>;
    totalSaleParticipants(overrides?: CallOverrides): Promise<BigNumber>;
    weiDeposited(overrides?: CallOverrides): Promise<BigNumber>;
    withdraw(overrides?: Overrides & {
        from?: PromiseOrValue<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        claim(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        claimAmount(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        deposit(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<void>;
        depositForWhitelistedAddress(index: PromiseOrValue<BigNumberish>, beneficiary: PromiseOrValue<string>, merkleProof: PromiseOrValue<BytesLike>[], overrides?: CallOverrides): Promise<void>;
        deposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        dpx(overrides?: CallOverrides): Promise<string>;
        dpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
        isWhitelistedAddressDeposited(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<boolean>;
        maxDeposits(overrides?: CallOverrides): Promise<BigNumber>;
        maxWhitelistDeposit(overrides?: CallOverrides): Promise<BigNumber>;
        merkleRoot(overrides?: CallOverrides): Promise<string>;
        owner(overrides?: CallOverrides): Promise<string>;
        rdpx(overrides?: CallOverrides): Promise<string>;
        rdpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
        saleClose(overrides?: CallOverrides): Promise<BigNumber>;
        saleStart(overrides?: CallOverrides): Promise<BigNumber>;
        saleWhitelistStart(overrides?: CallOverrides): Promise<BigNumber>;
        totalSaleParticipants(overrides?: CallOverrides): Promise<BigNumber>;
        weiDeposited(overrides?: CallOverrides): Promise<BigNumber>;
        withdraw(overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "TokenClaim(address,address,uint256)"(claimer?: PromiseOrValue<string> | null, beneficiary?: PromiseOrValue<string> | null, amount?: null): TokenClaimEventFilter;
        TokenClaim(claimer?: PromiseOrValue<string> | null, beneficiary?: PromiseOrValue<string> | null, amount?: null): TokenClaimEventFilter;
        "TokenDeposit(address,address,bool,uint256)"(purchaser?: PromiseOrValue<string> | null, beneficiary?: PromiseOrValue<string> | null, isWhitelistDeposit?: PromiseOrValue<boolean> | null, value?: null): TokenDepositEventFilter;
        TokenDeposit(purchaser?: PromiseOrValue<string> | null, beneficiary?: PromiseOrValue<string> | null, isWhitelistDeposit?: PromiseOrValue<boolean> | null, value?: null): TokenDepositEventFilter;
        "WithdrawEth(uint256)"(amount?: null): WithdrawEthEventFilter;
        WithdrawEth(amount?: null): WithdrawEthEventFilter;
    };
    estimateGas: {
        claim(beneficiary: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        claimAmount(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        deposit(beneficiary: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        depositForWhitelistedAddress(index: PromiseOrValue<BigNumberish>, beneficiary: PromiseOrValue<string>, merkleProof: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
        deposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<BigNumber>;
        dpx(overrides?: CallOverrides): Promise<BigNumber>;
        dpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
        isWhitelistedAddressDeposited(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<BigNumber>;
        maxDeposits(overrides?: CallOverrides): Promise<BigNumber>;
        maxWhitelistDeposit(overrides?: CallOverrides): Promise<BigNumber>;
        merkleRoot(overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        rdpx(overrides?: CallOverrides): Promise<BigNumber>;
        rdpxTokensAllocated(overrides?: CallOverrides): Promise<BigNumber>;
        saleClose(overrides?: CallOverrides): Promise<BigNumber>;
        saleStart(overrides?: CallOverrides): Promise<BigNumber>;
        saleWhitelistStart(overrides?: CallOverrides): Promise<BigNumber>;
        totalSaleParticipants(overrides?: CallOverrides): Promise<BigNumber>;
        weiDeposited(overrides?: CallOverrides): Promise<BigNumber>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        claim(beneficiary: PromiseOrValue<string>, overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        claimAmount(beneficiary: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        deposit(beneficiary: PromiseOrValue<string>, overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        depositForWhitelistedAddress(index: PromiseOrValue<BigNumberish>, beneficiary: PromiseOrValue<string>, merkleProof: PromiseOrValue<BytesLike>[], overrides?: PayableOverrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
        deposits(arg0: PromiseOrValue<string>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        dpx(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        dpxTokensAllocated(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isWhitelistedAddressDeposited(index: PromiseOrValue<BigNumberish>, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxDeposits(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxWhitelistDeposit(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        merkleRoot(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rdpx(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rdpxTokensAllocated(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        saleClose(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        saleStart(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        saleWhitelistStart(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        totalSaleParticipants(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        weiDeposited(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        withdraw(overrides?: Overrides & {
            from?: PromiseOrValue<string>;
        }): Promise<PopulatedTransaction>;
    };
}
